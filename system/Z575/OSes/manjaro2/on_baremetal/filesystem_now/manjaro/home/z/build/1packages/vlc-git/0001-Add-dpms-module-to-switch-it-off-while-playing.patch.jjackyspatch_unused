this version of the patch is for vlc-git
What this does is allow the power management to switch off your monitor while vlc video is paused, and prevent it(as vlc did previously) while the video is playing

Note: as per author's notes here: jjacky.com/2013-09-30-automatically-switch-dpms-off-in-vlc-2.1/
for this module to work correctly, this does require disabling the "Disable screensaver" option which is usually set by default, otherwise, vlc will keep disabling the screensaver every 30 seconds even when paused.
In vlc, Tools->Preferences->Video->Disable screensaver (make sure it's unset [ ])
AND also unset "Inhibit the power management daemon during playback" in Advanced.
Changing any of these options requires VLC to be restarted to have effect!
You also have to either add this line to ~/.config/vlc/vlcrc file:
extraintf=dpms
(or search for extraintf)
OR run vlc (once!) with --extraintf=dpms  and it will save that into that file.
OR you can try to add it via the Preferences, Interface but it won't work, currently.
This is to load dpms module, else this has no effect.

From 7ba4fee006335e6f38c098cf20059bbcd3d64b43 Mon Sep 17 00:00:00 2001
From: Olivier Brunel <jjk@jjacky.com>
Date: Sun, 1 Mar 2015 12:35:14 +0100
Subject: [PATCH] Add dpms module to switch it off while playing

Assumes it was on before/should be on again after. Point is to switch it off
when starting to play, and (back) on when pausing/stopping.

Signed-off-by: Olivier Brunel <jjk@jjacky.com>
---
diff --git a/modules/misc/dpms.c b/modules/misc/dpms.c
new file mode 100644
index 0000000..12b3b1d
--- /dev/null
+++ b/modules/misc/dpms.c
@@ -0,0 +1,228 @@
+/**
+ * dpms.c               Copyright (C) 2013 Olivier Brunel       GPL 3+
+ * based on inhibit.c   Copyright © 2007 Rafaël Carré           GPL 2+
+ * based on xdg.c       Copyright (C) 2008 Rémi Denis-Courmont  LGPL 2.1+
+ * */
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_input.h>
+#include <vlc_interface.h>
+#include <vlc_playlist.h>
+#include <assert.h>
+#include <signal.h>
+#include <spawn.h>
+#include <sys/wait.h>
+
+static int  Activate    (vlc_object_t *p_this);
+static void Deactivate  (vlc_object_t *p_this);
+
+static void Inhibit     (intf_thread_t *p_intf, bool suspend);
+
+static int StateChange  (vlc_object_t *p_input, const char *var,
+                         vlc_value_t prev, vlc_value_t value, void *data);
+static int ItemChange   (vlc_object_t *p_playlist, const char *var,
+                         vlc_value_t prev, vlc_value_t value, void *data);
+static void *Thread     (void *data);
+
+struct intf_sys_t
+{
+    playlist_t         *p_playlist;
+    vlc_thread_t        thread;
+    vlc_cond_t          update;
+    vlc_cond_t          inactive;
+    vlc_mutex_t         lock;
+    posix_spawnattr_t   attr;
+    bool                suspend;
+    bool                suspended;
+    bool                has_callback;
+};
+
+vlc_module_begin ()
+    set_shortname (N_("dpms"))
+    set_description (N_("Switch DPMS off while playing"))
+    set_capability ("interface", 10)
+    set_callbacks (Activate, Deactivate)
+vlc_module_end ()
+
+/*****************************************************************************
+ * Activate: initialize and create stuff
+ *****************************************************************************/
+static int Activate (vlc_object_t *p_this)
+{
+    intf_thread_t   *p_intf = (intf_thread_t *) p_this;
+    intf_sys_t      *p_sys;
+
+    p_sys = p_intf->p_sys = (intf_sys_t *) calloc (1, sizeof (intf_sys_t));
+    if (!p_sys)
+        return VLC_ENOMEM;
+
+    vlc_mutex_init (&p_sys->lock);
+    vlc_cond_init (&p_sys->update);
+    vlc_cond_init (&p_sys->inactive);
+    posix_spawnattr_init (&p_sys->attr);
+    /* Reset signal handlers to default and clear mask in the child process */
+    {
+        sigset_t set;
+
+        sigemptyset (&set);
+        posix_spawnattr_setsigmask (&p_sys->attr, &set);
+        sigaddset (&set, SIGPIPE);
+        posix_spawnattr_setsigdefault (&p_sys->attr, &set);
+        posix_spawnattr_setflags (&p_sys->attr, POSIX_SPAWN_SETSIGDEF
+                                              | POSIX_SPAWN_SETSIGMASK);
+    }
+
+    if (vlc_clone (&p_sys->thread, Thread, p_intf, VLC_THREAD_PRIORITY_LOW))
+    {
+        vlc_cond_destroy (&p_sys->inactive);
+        vlc_cond_destroy (&p_sys->update);
+        vlc_mutex_destroy (&p_sys->lock);
+        free (p_sys);
+        return VLC_ENOMEM;
+    }
+    p_sys->p_playlist = pl_Get (p_intf);
+    var_AddCallback (p_sys->p_playlist, "input-current", ItemChange, p_intf);
+    return VLC_SUCCESS;
+}
+
+/*****************************************************************************
+ * Deactivate: uninitialize and cleanup
+ *****************************************************************************/
+static void Deactivate (vlc_object_t *p_this)
+{
+    intf_thread_t *p_intf = (intf_thread_t*)p_this;
+    intf_sys_t *p_sys = p_intf->p_sys;
+    input_thread_t *p_input;
+
+    var_DelCallback (p_sys->p_playlist, "input-current", ItemChange, p_intf);
+
+    p_input = playlist_CurrentInput (p_sys->p_playlist);
+    if (p_input)
+    {
+        if (p_sys->has_callback)
+            var_DelCallback (p_input, "intf-event", StateChange, p_intf);
+        vlc_object_release (p_input);
+    }
+
+    Inhibit (p_intf, false);
+
+    /* Make sure xset is gone for good */
+    vlc_mutex_lock (&p_sys->lock);
+    while (p_sys->suspended)
+        vlc_cond_wait (&p_sys->inactive, &p_sys->lock);
+    vlc_mutex_unlock (&p_sys->lock);
+
+    vlc_cancel (p_sys->thread);
+    vlc_join (p_sys->thread, NULL);
+    posix_spawnattr_destroy (&p_sys->attr);
+    vlc_cond_destroy (&p_sys->inactive);
+    vlc_cond_destroy (&p_sys->update);
+    vlc_mutex_destroy (&p_sys->lock);
+
+    free (p_sys);
+}
+
+static void Inhibit (intf_thread_t *p_intf, bool suspend)
+{
+    intf_sys_t *p_sys = p_intf->p_sys;
+
+    /* in case xset take a little while to start up (e.g. 1 second), avoid
+     * waiting for it unless we really need to (clean up). */
+    vlc_mutex_lock (&p_sys->lock);
+    p_sys->suspend = suspend;
+    vlc_cond_signal (&p_sys->update);
+    vlc_mutex_unlock (&p_sys->lock);
+}
+
+static int StateChange (vlc_object_t *p_input, const char *var,
+                        vlc_value_t prev, vlc_value_t value, void *data)
+{
+    intf_thread_t *p_intf = data;
+    int state;
+
+    if (value.i_int != INPUT_EVENT_STATE)
+        return VLC_SUCCESS;
+
+    state = var_GetInteger (p_input, "state");
+
+    if ((state == PLAYING_S) == p_intf->p_sys->suspended)
+        return VLC_SUCCESS;
+
+    Inhibit (p_intf, state == PLAYING_S);
+
+    (void)var; (void)prev;
+    return VLC_SUCCESS;
+}
+
+static int ItemChange (vlc_object_t *p_playlist, const char *var,
+                       vlc_value_t prev, vlc_value_t value, void *data)
+{
+    intf_thread_t *p_intf = data;
+    intf_sys_t *p_sys = p_intf->p_sys;
+    input_thread_t *p_input;
+
+    p_input = playlist_CurrentInput (p_sys->p_playlist);
+    if (!p_input || p_input->b_dead)
+        return VLC_SUCCESS;
+
+    Inhibit (p_intf, true);
+    var_AddCallback (p_input, "intf-event", StateChange, p_intf);
+    p_sys->has_callback = true;
+    vlc_object_release (p_input);
+
+    (void)var; (void)prev; (void)value; (void)p_playlist;
+    return VLC_SUCCESS;
+}
+
+
+extern char **environ;
+
+VLC_NORETURN
+static void *Thread (void *data)
+{
+    intf_thread_t *p_intf = data;
+    intf_sys_t *p_sys = p_intf->p_sys;
+
+    vlc_mutex_lock (&p_sys->lock);
+    mutex_cleanup_push (&p_sys->lock);
+    for (;;)
+    {
+        while (p_sys->suspended == p_sys->suspend)
+            vlc_cond_wait (&p_sys->update, &p_sys->lock);
+
+        int canc = vlc_savecancel ();
+        char *argv[3] = {
+            (char *) "xset",
+            (char *) ((p_sys->suspend) ? "-dpms" : "+dpms"),
+            NULL,
+        };
+        pid_t pid;
+
+        vlc_mutex_unlock (&p_sys->lock);
+        if (!posix_spawnp (&pid, argv[0], NULL, &p_sys->attr,
+                           argv, environ))
+        {
+            int status;
+
+            /* Wait for command to complete */
+            while (waitpid (pid, &status, 0) == -1);
+        }
+        else
+            /* We don't handle the error, but busy looping would be worse :( */
+            msg_Warn (p_intf, "Failed to start xset");
+
+        vlc_mutex_lock (&p_sys->lock);
+        p_sys->suspended = p_sys->suspend;
+        if (!p_sys->suspended)
+            vlc_cond_signal (&p_sys->inactive);
+        vlc_restorecancel (canc);
+    }
+
+    vlc_cleanup_pop ();
+    assert (0);
+}
diff --git a/modules/misc/Makefile.am b/modules/misc/Makefile.am
index f9315e9..4a8bff4 100644
--- a/modules/misc/Makefile.am
+++ b/modules/misc/Makefile.am
@@ -5,6 +5,9 @@ libstats_plugin_la_SOURCES = misc/stats.c
 
 misc_LTLIBRARIES = liblogger_plugin.la libstats_plugin.la
 
+libdpms_plugin_la_SOURCES = misc/dpms.c
+misc_LTLIBRARIES += libdpms_plugin.la
+
 libaudioscrobbler_plugin_la_SOURCES = misc/audioscrobbler.c
 libaudioscrobbler_plugin_la_LIBADD = $(SOCKET_LIBS) $(LIBPTHREAD)
 misc_LTLIBRARIES += libaudioscrobbler_plugin.la
