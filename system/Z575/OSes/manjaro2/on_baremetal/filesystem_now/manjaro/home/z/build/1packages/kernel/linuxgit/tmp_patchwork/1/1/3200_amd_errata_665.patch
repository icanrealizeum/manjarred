diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h
index 56f4c66..0013fd4 100644
--- a/arch/x86/include/asm/msr-index.h
+++ b/arch/x86/include/asm/msr-index.h
@@ -284,6 +284,7 @@
 #define MSR_AMD64_OSVW_STATUS		0xc0010141
 #define MSR_AMD64_LS_CFG		0xc0011020
 #define MSR_AMD64_DC_CFG		0xc0011022
+#define MSR_AMD64_DE_CFG		0xC0011029
 #define MSR_AMD64_BU_CFG2		0xc001102a
 #define MSR_AMD64_IBSFETCHCTL		0xc0011030
 #define MSR_AMD64_IBSFETCHLINAD		0xc0011031
diff --git a/arch/x86/kernel/cpu/amd.c b/arch/x86/kernel/cpu/amd.c
index f5c69d8..76793fd 100644
--- a/arch/x86/kernel/cpu/amd.c
+++ b/arch/x86/kernel/cpu/amd.c
@@ -593,6 +593,7 @@ static void early_init_amd(struct cpuinfo_x86 *c)
 
 static const int amd_erratum_383[];
 static const int amd_erratum_400[];
+static const int amd_erratum_665[];
 static bool cpu_has_amd_erratum(struct cpuinfo_x86 *cpu, const int *erratum);
 
 static void init_amd_k8(struct cpuinfo_x86 *c)
@@ -698,6 +699,17 @@ static void init_amd_bd(struct cpuinfo_x86 *c)
 	}
 }
 
+bool activate_665erratum = true;
+EXPORT_SYMBOL(activate_665erratum);
+
+static int __init oksomefunc(char *str)
+{
+	activate_665erratum = false;
+	return 0;
+}
+#define kernel_arg_for_disable665 "no665wo"
+early_param(kernel_arg_for_disable665, oksomefunc);
+
 static void init_amd(struct cpuinfo_x86 *c)
 {
 	u32 dummy;
@@ -762,6 +774,43 @@ static void init_amd(struct cpuinfo_x86 *c)
 	if (c->x86 > 0x11)
 		set_cpu_cap(c, X86_FEATURE_ARAT);
 
+  if (cpu_has_amd_erratum(c, amd_erratum_665)) {
+    //XXX: this does get called for each core! so, 4 times!
+      pr_info(FW_INFO "CPU: '%s' has AMD errata 665 Integer Divide Instruction May Cause Unpredictable Behavior.'\n", c->x86_model_id);
+      if ( (0x12 == c->x86) && (1 == c->x86_model) &&
+          (0 == strncmp(c->x86_model_id, "AMD A6-3400M APU with Radeon(tm) HD Graphics", 45)) ) {
+        pr_info(FW_INFO "CPU: Double-checked CPU type. '%s'\n", c->x86_model_id);
+
+        if (activate_665erratum) {
+        pr_info(FW_INFO "CPU: Setting workaround for 665...(set '%s' in /proc/cmdline to disable)\n", kernel_arg_for_disable665);
+        /* 665 Integer Divide Instruction May Cause Unpredictable Behavior
+         * Description
+         * Under a highly specific and detailed set of internal timing conditions, the processor core may abort a
+         * speculative DIV or IDIV integer divide instruction (due to the speculative execution being redirected,
+         * for example due to a mispredicted branch) but may hang or prematurely complete the first instruction
+         * of the non-speculative path.
+         * Potential Effect on System
+         * Unpredictable system behavior, usually resulting in a system hang.
+         * Suggested Workaround
+         * BIOS should set MSRC001_1029[31].
+         * This workaround alters the DIV/IDIV instruction latency specified in the Software Optimization
+         * Guide for AMD Family 10h and 12h Processors, order# 40546. With this workaround applied, the
+         * DIV/IDIV latency for AMD Family 12h Processors are similar to the DIV/IDIV latency for
+         * AMD Family 10h Processors.
+         * Fix Planned
+         * No
+         * src: page 45/53 of http://support.amd.com/us/Processor_TechDocs/44739_12h_Rev_Gd.pdf (which is a broken link currently, see the 2012 saved archive.org one)
+         */
+        int err=msr_set_bit(MSR_AMD64_DE_CFG, 31);//FIXME: arch/x86/kernel/cpu/amd.c:802:9: warning: ISO C90 forbids mixed declarations and code [-Wdeclaration-after-statement]
+        if (err < 0) { //0=already set, 1=did set; <0 = error
+          pr_warn(FW_INFO "CPU: setting MSR failed for the 665 erratum workaround! err:%d", err);
+        }
+        } else {
+          pr_info(FW_INFO "CPU: not activating workaround for 665 due to kernel arg '%s' (see /proc/cmdline)\n", kernel_arg_for_disable665);
+        }
+      }
+  }
+
 	if (cpu_has_amd_erratum(c, amd_erratum_400))
 		set_cpu_bug(c, X86_BUG_AMD_APIC_C1E);
 
@@ -901,6 +950,8 @@ static const int amd_erratum_400[] =
 static const int amd_erratum_383[] =
 	AMD_OSVW_ERRATUM(3, AMD_MODEL_RANGE(0x10, 0, 0, 0xff, 0xf));
 
+static const int amd_erratum_665[] = AMD_LEGACY_ERRATUM(
+  AMD_MODEL_RANGE(0x12/*18*/, 0x1, 0x0, 0x1, 0x0));
 
 static bool cpu_has_amd_erratum(struct cpuinfo_x86 *cpu, const int *erratum)
 {
